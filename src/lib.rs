//! # zencodecs
//!
//! Unified image codec abstraction over multiple format-specific encoders and decoders.
//!
//! ## Overview
//!
//! zencodecs is a thin dispatch layer that provides:
//! - **Format detection** from magic bytes or file extensions
//! - **Codec dispatch** to format-specific implementations
//! - **Typed pixel buffers** via `imgref::ImgVec` and `rgb` crate types
//! - **Runtime codec registry** for enabling/disabling formats
//! - **Unified error handling** across all codecs
//!
//! Each codec is feature-gated. Enable only what you need:
//!
//! ```toml
//! [dependencies]
//! zencodecs = { version = "0.1", features = ["jpeg", "webp", "png"] }
//! ```
//!
//! ## Usage Examples
//!
//! ### Detect and Decode
//!
//! ```no_run
//! use zencodecs::{ImageFormat, DecodeRequest};
//!
//! let data: &[u8] = &[]; // your image bytes
//! let decoded = DecodeRequest::new(data).decode()?;
//! println!("{}x{} {:?}", decoded.width(), decoded.height(), decoded.pixels);
//! # Ok::<(), zencodecs::CodecError>(())
//! ```
//!
//! ### Encode to Different Format
//!
//! ```no_run
//! use zencodecs::{EncodeRequest, ImageFormat};
//! use zencodecs::pixel::{ImgVec, Rgba};
//!
//! let pixels = ImgVec::new(vec![Rgba { r: 0u8, g: 0, b: 0, a: 255 }; 100*100], 100, 100);
//! let webp = EncodeRequest::new(ImageFormat::WebP)
//!     .with_quality(85.0)
//!     .encode_rgba8(pixels.as_ref())?;
//! println!("Encoded {} bytes", webp.data.len());
//! # Ok::<(), zencodecs::CodecError>(())
//! ```
//!
//! ### Probe Image Metadata
//!
//! ```no_run
//! use zencodecs::ImageInfo;
//!
//! let data: &[u8] = &[]; // your image bytes
//! let info = ImageInfo::from_bytes(data)?;
//! println!("{}x{} {:?}", info.width, info.height, info.format);
//! # Ok::<(), zencodecs::CodecError>(())
//! ```
//!
//! ### Control Available Codecs
//!
//! ```no_run
//! use zencodecs::{CodecRegistry, ImageFormat, DecodeRequest};
//!
//! let registry = CodecRegistry::none()
//!     .with_decode(ImageFormat::Jpeg, true)
//!     .with_decode(ImageFormat::Png, true);
//!
//! let data: &[u8] = &[]; // your image bytes
//! let decoded = DecodeRequest::new(data)
//!     .with_registry(&registry)
//!     .decode()?;
//! # Ok::<(), zencodecs::CodecError>(())
//! ```
//!
//! ## What This Crate Does NOT Do
//!
//! - **No image processing**: No resize, crop, rotate. Use `zenimage` or similar.
//! - **No color management**: No ICC profile application (yet).
//! - **No streaming**: One-shot decode/encode only (streaming planned).
//! - **No animation**: First frame only for animated formats (animation planned).

#![cfg_attr(not(feature = "std"), no_std)]
#![forbid(unsafe_code)]

extern crate alloc;

mod codecs;
pub mod config;
mod decode;
mod encode;
mod error;
mod format;
mod info;
mod limits;
pub mod pixel;
mod probe;
mod registry;

// Re-exports
pub use decode::{DecodeOutput, DecodeRequest};
pub use encode::{EncodeOutput, EncodeRequest};
pub use error::CodecError;
pub use format::ImageFormat;
pub use info::ImageInfo;
pub use limits::{ImageMetadata, Limits, Stop};
pub use pixel::PixelData;
pub use probe::ProbeResult;
pub use registry::CodecRegistry;

// zencodec-types trait re-exports
pub use zencodec_types::{Decoding, DecodingJob, Encoding, EncodingJob};

#[cfg(feature = "png")]
pub use codecs::png_zencodec::{PngDecodeJob, PngDecoding, PngEncodeJob, PngEncoding};
